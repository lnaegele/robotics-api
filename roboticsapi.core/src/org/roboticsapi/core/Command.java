/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. 
 *
 * Copyright 2010-2017 ISSE, University of Augsburg 
 */

package org.roboticsapi.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.Vector;

import org.roboticsapi.core.RoboticsRuntime.CommandHook;
import org.roboticsapi.core.eventhandler.ExceptionThrower;
import org.roboticsapi.core.eventhandler.StateRaiser;
import org.roboticsapi.core.exception.RoboticsException;
import org.roboticsapi.core.runtime.CommandRealtimeException;
import org.roboticsapi.core.sensor.Assignment;
import org.roboticsapi.core.sensor.Observer;
import org.roboticsapi.core.state.AliasState;
import org.roboticsapi.core.state.AndState;
import org.roboticsapi.core.state.CommandState;
import org.roboticsapi.core.state.DerivedState;
import org.roboticsapi.core.state.ExceptionState;
import org.roboticsapi.core.state.FalseState;
import org.roboticsapi.core.state.OrState;
import org.roboticsapi.core.state.TrueState;
import org.roboticsapi.core.util.RAPILogger;

/**
 * A Robotics API command (telling a device to execute an action)
 */
public abstract class Command {

	/**
	 * State raised when a command got a Cancel requests
	 * 
	 */
	public static class CancelState extends CommandState {
	}

	public static class WatchdogTimeoutException extends CommandRealtimeException {

		/**
		 * 
		 */
		private static final long serialVersionUID = 1935017727232269234L;

		public WatchdogTimeoutException(String message, Command command) {
			super(message, command);
		}

	}

	/**
	 * An ExceptionHandler handles all CommandExceptions that occur during execution
	 * of a Command.
	 * 
	 * This includes Exceptions generated by JavaExceptionThrowers, JavaExecutors
	 * and SensorListeners, but excludes Exceptions due to abnormal Command
	 * termination (e.g. in case of UnhandledErrors).
	 * 
	 */
	public interface UnhandledExceptionHandler {
		void handleException(CommandRuntimeException exc);
	}

	/**
	 * The DefaultExceptionLogger is the default ExceptionHandler used by all
	 * Commands. All Exceptions are logged by RAPILogger.getLogger().
	 */
	private class DefaultExceptionLogger implements UnhandledExceptionHandler {

		@Override
		public void handleException(CommandRuntimeException exc) {
			RAPILogger.getLogger().log(RAPILogger.ERRORLEVEL,
					"Unhandled RoboticsException during execution of Command " + getName(), exc);

		}

	}

	/** event usage listeners */
	private final List<StateValidator> stateValidators = new Vector<StateValidator>();

	/** Name of the command */
	private String name;

	/** Runtime this command belongs to */
	private RoboticsRuntime runtime;

	/** The RCC command executing this command */
	private CommandHandle commandHandle = null;

	/** Event handlers for the action and device */
	private final List<EventHandler> eventHandlers = new Vector<EventHandler>();

	/** Event handlers for the action and device */
	protected final List<ExceptionHandler<?>> exceptionHandlers = new Vector<ExceptionHandler<?>>();

	/** Monitors on sensors in this command */
	private final List<Observer<?>> observers = new Vector<Observer<?>>();

	private final List<Assignment<?>> assignments = new ArrayList<Assignment<?>>();

	/** The watchdog timeout for this Command. 0 means no watchdog. */
	private double watchdogTimeout = 0;

	/** Whether this Command is sealed, i.e. immutable. */
	private boolean sealed = false;

	/** The State indicating that this Command's execution is 'Done'. */
	private final OrState doneState = new OrState();

	/** The State indicating that this Command allows takeover. */
	private final OrState takeoverAllowedState = new OrState();

	/** The default ExceptionHandler of this Commands. */
	private UnhandledExceptionHandler exceptionHandler = new DefaultExceptionLogger();

	/**
	 * Strategy for handling otherwise unhandled errors during command execution
	 */
	private static InnerExceptionStrategy defaultExceptionStrategy = new AbortCommandAndThrowStrategy();

	private final WatchdogTimeoutException watchdogException;

	/**
	 * Builds an empty command.
	 * 
	 * @param name the Command's name
	 */
	public Command(String name) {
		setName(name);

		watchdogException = new WatchdogTimeoutException("Watchdog timeout in Command " + getName(), this);

		addStateValidator(new StateValidator() {

			@Override
			public boolean validateState(State state) throws RoboticsException {

				// elementary states are allowed everywhere
				if (state instanceof TrueState || state instanceof FalseState) {
					return true;
				}

				// composed states are allowed if all children are allowed
				if (state instanceof DerivedState) {
					for (State childState : ((DerivedState) state).getStates()) {
						if (!Command.this.validateState(childState)) {
							return false;
						}
					}
					return true;
				}

				// TODO: redundant, eliminate?
				// alias states are allowed if the aliased state is allowed
				if (state instanceof AliasState) {
					return Command.this.validateState(((AliasState) state).getOther());
				}

				// sensor states of this runtime are allowed everywhere
				if (state instanceof SensorState) {
					return ((SensorState) state).getSensor().getRuntime() == null
							|| ((SensorState) state).getSensor().getRuntime() == getRuntime();
				}

				// raised states may be used
				for (EventHandler eh : getEventHandlers()) {
					if (eh.getEffect() instanceof StateRaiser
							&& ((StateRaiser) eh.getEffect()).getRaisedState().equals(state)) {
						return true;
					}
				}

				// allow command states (except for completion state)
				if (state instanceof CommandState && ((CommandState) state).getCommand() == Command.this) {
					return true;
				}

				// exception states are valid if corresponding exception can
				// occur in the command
				if (state instanceof ExceptionState) {
					if (getInnerExceptions().contains(((ExceptionState) state).getException())) {
						return true;
					}
				}

				return false;
			}
		});
	}

	/**
	 * Retrieves the Command's name
	 * 
	 * @return name of the command
	 */
	public String getName() {
		return name;
	}

	/**
	 * Sets the Command's name
	 * 
	 * @param name new name
	 */
	public void setName(String name) {
		this.name = name;
	}

	/**
	 * Event fired when the command is started
	 * 
	 * @return start event
	 */
	public State getStartedState() {
		return getActiveState().hasBeenActive();
	}

	/**
	 * Event fired while the command is active
	 * 
	 * @return active event
	 */
	public State getActiveState() {
		return new ActiveState().setCommand(this);
	}

	/**
	 * Event fired when a command is active
	 */
	public static class ActiveState extends CommandState {
	}

	/**
	 * Retrieves an event that the command is no longer running (stopped or
	 * completed successfully)
	 * 
	 * @return a completion event
	 */
	public State getCompletedState() {
		return getDoneState().or(getStoppedState());
	}

	/**
	 * Retrieves an event that the command is no longer running (stopped or
	 * completed successfully)
	 * 
	 * @return a stopped event
	 */
	public State getStoppedState() {
		return getActiveState().hasBeenActive().and(getActiveState().not());
	}

	/**
	 * Retrieves an state that the command is done (completed its contents
	 * successfully / is currently executing its very last step)
	 * 
	 * @return a done state
	 */
	public State getDoneState() {
		return new AndState(doneState, getActiveState());
	}

	/**
	 * Specifies an additional condition that leads to this Command's DoneState.
	 * 
	 * The given State is joined with all other such conditions by OR operator to
	 * determine the final DoneState condition.
	 * 
	 * @param doneWhenStateReached the additional condition for the occurrence of
	 *                             this Command's DoneState
	 * @throws RoboticsException if Command already sealed
	 */
	public void addDoneStateCondition(State doneWhenStateReached) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		doneState.addState(doneWhenStateReached);
	}

	/**
	 * Retrieves a State indicating that the Command allows to be taken over.
	 * 
	 * @return a takeover allowed state
	 */
	public State getTakeoverAllowedState() {
		return new AndState(takeoverAllowedState, getActiveState());
	}

	/**
	 * Specifies an additional State that indicates that this Command allows to be
	 * taken over.
	 * 
	 * The given State is joined with all other such conditions by OR operator to
	 * determine the final takeover allowance state.
	 * 
	 * @param state the state indicating takeover allowed
	 * @throws RoboticsException if Command already sealed
	 */
	public void addTakeoverAllowedCondition(State state) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		takeoverAllowedState.addState(state);
	}

	/**
	 * Retrieves a State indicating that the Command got a Cancel request
	 * 
	 * @return the cancel State
	 */
	public State getCancelState() {
		return new CancelState().setCommand(this);
	}

	/**
	 * Retrieves the event handlers of this command
	 * 
	 * @return List of all event handlers
	 */
	public List<EventHandler> getEventHandlers() {
		return Collections.unmodifiableList(eventHandlers);
	}

	// TODO: Should we prevent calls before sealing?
	public List<CommandRealtimeException> getExceptions(Class<? extends CommandRealtimeException> exceptionType) {
		List<CommandRealtimeException> matching = new ArrayList<CommandRealtimeException>();

		for (CommandRealtimeException e : getExceptions()) {
			if (exceptionType.isAssignableFrom(e.getClass())) {
				matching.add(e);
			}
		}

		return matching;
	}

	// TODO: Should we prevent calls before sealing?
	public CommandRealtimeException getInnerException(Class<? extends CommandRealtimeException> exceptionType)
			throws CommandException {

		Set<CommandRealtimeException> exceptions = getInnerExceptions();

		for (CommandRealtimeException e : exceptions) {
			if (e.getClass().equals(exceptionType)) {
				return e;
			}
		}

		throw new CommandException("Command does not throw Exceptions of type " + exceptionType);

	}

	/**
	 * Gets the States indicating (possibly handled) errors during execution of this
	 * Command.
	 * 
	 * @return list of States indicating (possibly handled) errors
	 */
	// TODO: Should we prevent calls before sealing?
	public Set<CommandRealtimeException> getInnerExceptions() {
		Set<CommandRealtimeException> errors = collectInnerExceptions();

		if (errors == null) {
			errors = new HashSet<CommandRealtimeException>();
		}

		if (needsWatchdog()) {

			errors.add(watchdogException);
		}

		for (EventHandler handler : eventHandlers) {
			if (handler.getEffect() instanceof ExceptionThrower) {
				if (!errors.contains(((ExceptionThrower) handler.getEffect()).getThrownException())) {
					errors.add(((ExceptionThrower) handler.getEffect()).getThrownException());
				}
			}
		}

		return errors;
	}

	/**
	 * Collects all States inside the implementation of this Command indicating
	 * errors.
	 * 
	 * @return list of States indicating errors, may be null.
	 */
	protected abstract Set<CommandRealtimeException> collectInnerExceptions();

	/**
	 * Adds an event handler.
	 * 
	 * @param eventhandler event handler to add
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addEventHandler(final EventHandler eventhandler) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		eventhandler.setContext(this);
		eventHandlers.add(eventhandler);
	}

	/**
	 * Specifies an EventEffect to be executed upon each entering of the specified
	 * State.
	 * 
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateEnteredHandler(final State state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateEntered(state, effect));
	}

	/**
	 * Specifies an EventEffect to be executed upon the first entering of the
	 * specified State only.
	 * 
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateFirstEnteredHandler(final State state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateFirstEntered(state, effect));
	}

	/**
	 * Specifies an EventEffect to be executed upon the each leaving of the
	 * specified State.
	 * 
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateLeftHandler(final State state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateLeft(state, effect));
	}

	/**
	 * Specifies an EventEffect to be executed upon the first leaving of the
	 * specified State only.
	 * 
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateFirstLeftHandler(final State state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateFirstLeft(state, effect));
	}

	/**
	 * Adds a handler for a State that is indicating an error.
	 * 
	 * @param errorhandler the error handler
	 * @throws RoboticsException if Command is already sealed
	 */
	public <T extends CommandRealtimeException> void addExceptionHandler(ExceptionHandler<T> errorhandler)
			throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		exceptionHandlers.add(errorhandler);
	}

	/**
	 * Specifies an EventEffect to be executed upon each occurrence of the specified
	 * error.
	 * 
	 * @param <T>
	 * 
	 * @param exceptionType the type of exception to react to
	 * @param effect        the effect to execute
	 * @param handled       if the handler handles the exception completely;
	 *                      otherwise it will be propagated
	 * @throws RoboticsException if Command is already sealed
	 */
	public <T extends CommandRealtimeException> void addExceptionHandler(final Class<T> exceptionType,
			final EventEffect effect, boolean handled) throws RoboticsException {

		addExceptionHandler(new ExceptionHandler<T>(exceptionType, effect, handled));
	}

	/**
	 * Specifies an EventEffect to be executed upon each occurrence of the specified
	 * error. The error is not treated as handled (i.e. will be propagated).
	 * 
	 * @param <T>
	 * 
	 * @param exceptionType the type of exception to react to
	 * @param effect        the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public <T extends CommandRealtimeException> void addExceptionHandler(final Class<T> exceptionType,
			final EventEffect effect) throws RoboticsException {

		addExceptionHandler(exceptionType, effect, false);
	}

	/**
	 * Retrieves the runtime of the command
	 * 
	 * @return the robotics runtimes
	 */
	public RoboticsRuntime getRuntime() {
		return runtime;
	}

	/**
	 * Sets the runtime of the command
	 * 
	 * @param runtime the robotics runtime
	 */
	protected void setRuntime(final RoboticsRuntime runtime) {

		this.runtime = runtime;
	}

	/**
	 * Start execution of the command.
	 * 
	 * @return An RPI RCC net for the command
	 * @throws RoboticsException when an error occurs
	 */
	public CommandHandle start() throws RoboticsException {
		CommandHandle ret = load();
		ret.start();
		return ret;
	}

	/**
	 * Schedule this Command for execution right after a currently running Command.
	 * 
	 * The CommandHandle of the currently running Command has to be specified.
	 * 
	 * @param other CommandHandle of the Command that this Command should be
	 *              scheduled after
	 * @return the CommandHandle for this Command
	 * @throws RoboticsException if Command scheduling failed
	 */
	public CommandHandle scheduleAfter(CommandHandle other) throws RoboticsException {
		CommandHandle ret = load();
		ret.scheduleAfter(other);
		return ret;
	}

	/**
	 * Prepares this Command for execution.
	 * 
	 * This involves creating default EventHandlers for unhandled errors and
	 * creating EventHandlers for command completion.
	 * 
	 * @throws RoboticsException if sealing failed
	 */
	public void seal() throws RoboticsException {
		if (sealed) {
			return;
		}

		for (CommandHook hook : getRuntime().getCommandHooks()) {
			hook.commandSealHook(this);
		}

		try {
			processExceptionHandlers();

		} catch (CommandException e) {

		} catch (Exception e) {
		}
		handleUnhandledInnerExceptions();
		handleCompletion();

		sealed = true;
	}

	private void processExceptionHandlers() throws RoboticsException {

		Set<CommandRealtimeException> handledExceptions = new HashSet<CommandRealtimeException>();

		for (ExceptionHandler<?> handler : exceptionHandlers) {

			boolean canOccur = false;
			for (CommandRealtimeException exc : getInnerExceptions()) {
				if (handledExceptions.contains(exc)) {
					continue;
				}

				if (handler.getExceptionType().isAssignableFrom(exc.getClass())) {
					exc.setCommand(this);
					addEventHandler(EventHandler.OnStateEntered(new ExceptionState(exc), handler.getEffect()));
					if (handler.isHandled()) {
						handledExceptions.add(exc);
					}
					canOccur = true;
				}
			}
			if (!canOccur) {
				throw new CommandException(
						"Exceptions of type " + handler.getExceptionType() + " do not occur in the given command.");
			}
		}
	}

	/**
	 * Checks if this Command is sealed (see seal()).
	 * 
	 * @return true, if Command is sealed
	 */
	public boolean isSealed() {
		return sealed;
	}

	/**
	 * Loads this Command to its RoboticsRuntime.
	 * 
	 * @return the CommandHandle for this Command
	 * @throws RoboticsException if loading failed
	 */
	private CommandHandle load() throws RoboticsException {
		seal();
		return runtime.load(this);
	}

	/**
	 * Creates completion logic (e.g. appropriate EventHandlers) as part of the
	 * seal() process.
	 * 
	 * @throws RoboticsException if creating completion logic failed
	 */
	protected abstract void handleCompletion() throws RoboticsException;

	/**
	 * Creates EventHandlers for unhandled errors inside this Command (i.e. result
	 * of getUnhandledInnerErrors()).
	 * 
	 * @throws RoboticsException if creating error handlers failed
	 */
	protected void handleUnhandledInnerExceptions() throws RoboticsException {
		for (CommandRealtimeException error : new ArrayList<CommandRealtimeException>(getExceptions())) {
			defaultExceptionStrategy.handleException(this, error);
		}
	}

	/**
	 * Start execution of the command and wait for completion
	 * 
	 * @throws RoboticsException when an error occurs
	 */
	public void execute() throws RoboticsException {
		start().waitComplete();
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 * 
	 * @param <T>      Generic type of the Observer.
	 * @param sensor   The sensor value to observe.
	 * @param listener The listener observing the sensor value.
	 * @throws RoboticsException
	 */
	public <T> void addObserver(Sensor<T> sensor, SensorListener<T> listener) throws RoboticsException {
		addObserver(new Observer<T>(this, sensor, listener));
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 * 
	 * @param <T>      Generic type of the Observer.
	 * @param sensor   The sensor value to observe.
	 * @param listener The listener observing the sensor value.
	 * @param async    Notify the listener asynchronously
	 * @throws RoboticsException
	 * 
	 */
	public <T> void addObserver(Sensor<T> sensor, SensorListener<T> listener, boolean async) throws RoboticsException {
		if (sensor == null) {
			throw new IllegalArgumentException("Sensor must not be null.");
		}

		addObserver(new Observer<T>(this, sensor, listener, async));
	}

	/**
	 * Adds an Observer to this Command explicitly.
	 * 
	 * @param observer The Observer to add.
	 * @throws RoboticsException
	 */
	public <T> void addObserver(Observer<T> observer) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		if (!observer.getSensor().isAvailable()) {
			throw new RoboticsException("The given sensor is not available.");
		}
		observer.setCommand(this);
		observers.add(observer);
	}

	/**
	 * Retrieves the command handle of the (running) command
	 * 
	 * @return command handle
	 */
	public CommandHandle getCommandHandle() {
		return commandHandle;
	}

	/**
	 * Retrieves the default strategy for handling otherwise unhandled errors during
	 * execution of commands
	 * 
	 * @return the default error handling strategy
	 */
	public static InnerExceptionStrategy getDefaultExceptionStrategy() {
		return defaultExceptionStrategy;
	}

	/**
	 * Sets the default strategy for handling otherwise unhandled errors during
	 * execution of commands
	 * 
	 * @param strategy The strategy to use for unhandled errors
	 */
	public static void setDefaultExceptionStrategy(final InnerExceptionStrategy strategy) {
		defaultExceptionStrategy = strategy;
	}

	/**
	 * Sets the command handle of the running command
	 * 
	 * @param handle command handle of this command
	 */
	public void setCommandHandle(final CommandHandle handle) {
		commandHandle = handle;
	}

	/**
	 * Gets the ExceptionHandler used for handling CommandExceptions during
	 * execution of this Command.
	 * 
	 * @return the ExceptionHandler
	 */
	public UnhandledExceptionHandler getUnhandledExceptionHandler() {
		return exceptionHandler;
	}

	/**
	 * Handles a CommandException that occurred during execution of this Command.
	 * 
	 * This implementation forwads the exception to the Command's ExceptionHandler.
	 * 
	 * @param e the CommandException that occurred
	 */
	public void handleException(CommandRuntimeException e) {
		try {
			getUnhandledExceptionHandler().handleException(e);
		} catch (Exception exc) {
			RAPILogger.getLogger().log(RAPILogger.ERRORLEVEL,
					"Unhandled Exception when handling Exceptions in Command " + getName(), exc);
		}
	}

	/**
	 * Sets ExceptionHandler for this Command.
	 * 
	 * @param handler the new ExceptionHandler
	 */
	public void setUnhandledExceptionHandler(UnhandledExceptionHandler handler) {
		this.exceptionHandler = handler;
	}

	/**
	 * Retrieves the Observers of this Command.
	 * 
	 * @return list of Observers
	 */
	public List<Observer<?>> getObservers() {
		return observers;
	}

	/**
	 * Gets whether this command needs a stable connection to the Robotics API
	 * during execution
	 * 
	 * @return if keep alive mechanism is necessary
	 */
	public boolean needsWatchdog() {
		return watchdogTimeout > 0;
	}

	/**
	 * Gets the timeout (in s) after which the connection to the Robotics API is
	 * assumed to have failed during execution of this Action.
	 * 
	 * @return the watchdog timeout
	 */
	public double getWatchdogTimeout() {
		return watchdogTimeout;
	}

	/**
	 * Sets the timeout (in s) after which the connection to the Robotics API is
	 * assumed to have failed during execution of this Action. A value of 0 (zero)
	 * has the meaning of an infinite timeout (i.e., no check).
	 * 
	 * @param watchdogTimeout the timeout for the watchdog in s
	 * @throws RoboticsException
	 */

	public void setWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		if (watchdogTimeout < 0) {
			throw new IllegalArgumentException("Negative values are not allowed for timeouts.");
		}

		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		this.watchdogTimeout = watchdogTimeout;
	}

	/**
	 * Sets the watchdog timeout of this Command to the specified value.
	 * 
	 * @param watchdogTimeout the watchdog timeout value
	 * @throws RoboticsException if Command is already sealed
	 */
	public void overrideWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		setWatchdogTimeout(watchdogTimeout);

		overrideWatchdogTimeoutInternal(watchdogTimeout);
	}

	/**
	 * Sets the watchdog timeout of this Command to the specified value, if this
	 * already Command uses a watchdog and the current timeout is shorter than the
	 * specified value.
	 * 
	 * @param watchdogTimeout the watchdog timeout
	 * @throws RoboticsException the robotics exception
	 */
	public void relaxWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		if (this.watchdogTimeout != 0 && this.watchdogTimeout < watchdogTimeout) {
			setWatchdogTimeout(watchdogTimeout);

			relaxWatchdogTimeoutInternal(watchdogTimeout);
		}
	}

	/**
	 * Sets the watchdog timeout of this Command implementation to the specified
	 * value.
	 * 
	 * @param watchdogTimeout the watchdog timeout value
	 * @throws RoboticsException if Command is already sealed
	 */
	protected abstract void overrideWatchdogTimeoutInternal(double watchdogTimeout) throws RoboticsException;

	/**
	 * Sets the watchdog timeout of this Command implementation to the specified
	 * value, if this already Command uses a watchdog and the current timeout is
	 * shorter than the specified value.
	 * 
	 * @param watchdogTimeout the watchdog timeout
	 * @throws RoboticsException the robotics exception
	 */
	protected abstract void relaxWatchdogTimeoutInternal(double watchdogTimeout) throws RoboticsException;

	/**
	 * Gets all errors that can occur inside this Command during its execution and
	 * for which no EventHandler has been specified.
	 * 
	 * @return List of States that represent unhandled errors
	 */
	// TODO: Should we prevent calls before sealing?
	public List<CommandRealtimeException> getExceptions() {
		List<CommandRealtimeException> unhandled = new ArrayList<CommandRealtimeException>();

		for (CommandRealtimeException e : getInnerExceptions()) {
			boolean handled = false;

			for (ExceptionHandler<?> h : exceptionHandlers) {
				if (h.getExceptionType().isAssignableFrom(e.getClass()) && h.isHandled()) {
					handled = true;
				}
			}

			if (!handled) {
				unhandled.add(e);
			}
		}

		return unhandled;
	}

	/**
	 * Validates whether a given State is valid in the context of this Command.
	 * 
	 * @param state the event
	 * @return true, if successful
	 * @throws RoboticsException if validation failed
	 */
	public final boolean validateState(State state) throws RoboticsException {
		if (state == null) {
			return true;
		}
		for (StateValidator listener : stateValidators) {
			if (listener.validateState(state)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Adds a StateValidator that is queried upon validateState(State) to determine
	 * State validity.
	 * 
	 * @param validator the StateValidator
	 */
	public void addStateValidator(StateValidator validator) {
		stateValidators.add(validator);
	}

	public <T> void assign(Sensor<T> source, PersistContext<T> target) {
		assignments.add(new Assignment<T>(source, target));
	}

	public List<Assignment<?>> getAssignments() {
		return assignments;
	}

}
