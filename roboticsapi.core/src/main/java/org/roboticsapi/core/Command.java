/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/. 
 *
 * Copyright 2013-2019 ISSE, University of Augsburg 
 */

/*
 *
 */
package org.roboticsapi.core;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.Vector;
import java.util.logging.Level;

import org.roboticsapi.core.RoboticsRuntime.CommandHook;
import org.roboticsapi.core.exception.RoboticsException;
import org.roboticsapi.core.realtimevalue.Assignment;
import org.roboticsapi.core.realtimevalue.realtimeboolean.CommandRealtimeBoolean;
import org.roboticsapi.core.realtimevalue.realtimeboolean.RealtimeBoolean;
import org.roboticsapi.core.realtimevalue.realtimedouble.RealtimeDouble;
import org.roboticsapi.core.runtime.CommandRealtimeException;
import org.roboticsapi.core.util.RAPILogger;

/**
 * A Robotics API command
 */
public abstract class Command {

	protected RealtimeDouble commandExecutionTime;

	public static class ExecutionTimeRealtimeDouble extends RealtimeDouble {

		public ExecutionTimeRealtimeDouble(Command command) {
			super(command);
		}

		@Override
		public boolean isAvailable() {
			return true;
		}

		@Override
		public String toString() {
			return "t";
		}
	}

	/**
	 * RealtimeBoolean evaluating to true when a command received a Cancel request
	 */
	public static class CancelRealtimeBoolean extends CommandRealtimeBoolean {
		public CancelRealtimeBoolean(Command scope) {
			super(scope);
		}
	}

	public static class WatchdogTimeoutException extends CommandRealtimeException {
		private static final long serialVersionUID = 1935017727232269234L;

		public WatchdogTimeoutException(String message) {
			super(message);
		}

	}

	/**
	 * An ExceptionHandler handles all CommandExceptions that occur during execution
	 * of a Command.
	 *
	 * This includes Exceptions generated by JavaExceptionThrowers, JavaExecutors
	 * and SensorListeners, but excludes Exceptions due to abnormal Command
	 * termination (e.g. in case of UnhandledErrors).
	 */
	public interface UnhandledExceptionHandler {
		void handleException(CommandRuntimeException exc);
	}

	/**
	 * The DefaultExceptionLogger is the default ExceptionHandler used by all
	 * Commands. All Exceptions are logged by RAPILogger.getLogger().
	 */
	private class DefaultExceptionLogger implements UnhandledExceptionHandler {
		@Override
		public void handleException(CommandRuntimeException exc) {
			RAPILogger.getLogger(this).log(Level.SEVERE,
					"Unhandled RoboticsException during execution of Command " + getName(), exc);

		}
	}

	/**
	 * An ExceptionAggregator decides which exception to throw when multiple errors
	 * occured during command execution.
	 */
	public interface ExceptionAggegator {
		CommandException aggregate(List<CommandException> exceptions);
	}

	private class DefaultExceptionAggregator implements ExceptionAggegator {
		@Override
		public CommandException aggregate(List<CommandException> exceptions) {
			return exceptions.get(0);
		}

	}

	/** Name of the command */
	private final String name;

	/** Runtime this command belongs to */
	private final RoboticsRuntime runtime;

	/** The RCC command executing this command */
	private CommandHandle commandHandle = null;

	private int loadCount = 0;

	/** Event handlers for the action and device */
	private final List<EventHandler> eventHandlers = new ArrayList<EventHandler>();

	/** Handled exceptions (that don't lead to command termination) */
	private final List<CommandRealtimeException> handledExceptions = new ArrayList<CommandRealtimeException>();

	/** States that lead to exceptions */
	private final Map<CommandRealtimeException, RealtimeBoolean> exceptionConditions = new HashMap<CommandRealtimeException, RealtimeBoolean>();

	/** Monitors on sensors in this command */
	private final List<Observer<?>> observers = new Vector<Observer<?>>();

	private final List<Assignment<?>> assignments = new ArrayList<Assignment<?>>();

	/** The watchdog timeout for this Command. 0 means no watchdog. */
	private double watchdogTimeout = 0;

	/** Whether this Command is sealed, i.e. immutable. */
	private boolean sealed = false;

	/** The default ExceptionHandler of this Commands. */
	private UnhandledExceptionHandler exceptionHandler = new DefaultExceptionLogger();

	/** The default ExceptionAggregator of this Commands. */
	private ExceptionAggegator exceptionAggregator = new DefaultExceptionAggregator();

	private final WatchdogTimeoutException watchdogException;

	/**
	 * Builds an empty command.
	 *
	 * @param name the Command's name
	 */
	public Command(String name, RoboticsRuntime runtime) {
		this.runtime = runtime;
		this.name = name;

		watchdogException = new WatchdogTimeoutException("Watchdog timeout");
		commandExecutionTime = new ExecutionTimeRealtimeDouble(this);
	}

	/**
	 * Retrieves the Command's name
	 *
	 * @return name of the command
	 */
	public String getName() {
		return name;
	}

	/**
	 * Retrieves a State indicating that the Command got a Cancel request
	 *
	 * @return the cancel State
	 */
	public RealtimeBoolean getCancelState() {
		return new CancelRealtimeBoolean(this);
	}

	/**
	 * Retrieves the event handlers of this command
	 *
	 * @return List of all event handlers
	 */
	public List<EventHandler> getEventHandlers() {
		return Collections.unmodifiableList(eventHandlers);
	}

	public List<CommandRealtimeException> getExceptions(Class<? extends CommandRealtimeException> exceptionType) {
		List<CommandRealtimeException> matching = new ArrayList<CommandRealtimeException>();

		for (CommandRealtimeException e : getExceptions()) {
			if (exceptionType.isAssignableFrom(e.getClass())) {
				matching.add(e);
			}
		}

		return matching;
	}

	public CommandResult getExceptionResult(CommandRealtimeException exception) {
		for (CommandResult result : getCommandResults()) {
			if (result.getException() == exception) {
				return result;
			}
		}
		return null;
	}

	public List<CommandRealtimeException> getInnerExceptions(Class<? extends CommandRealtimeException> exceptionType)
			throws CommandException {
		List<CommandRealtimeException> matching = new ArrayList<CommandRealtimeException>();
		Set<CommandRealtimeException> exceptions = getInnerExceptions();

		for (CommandRealtimeException e : exceptions) {
			if (e.getClass().equals(exceptionType)) {
				matching.add(e);
			}
		}

		return matching;
	}

	/**
	 * Gets the States indicating (possibly handled) errors during execution of this
	 * Command.
	 *
	 * @return list of States indicating (possibly handled) errors
	 */
	public Set<CommandRealtimeException> getInnerExceptions() {
		Set<CommandRealtimeException> errors = collectInnerExceptions();

		if (needsWatchdog()) {
			errors.add(watchdogException);
		}

		errors.addAll(exceptionConditions.keySet());
		return errors;
	}

	/**
	 * Collects all errors inside the implementation of this Command
	 *
	 * @return list of errors.
	 */
	protected abstract Set<CommandRealtimeException> collectInnerExceptions();

	/**
	 * Adds an event handler.
	 *
	 * @param eventhandler event handler to add
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addEventHandler(final EventHandler eventhandler) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		eventhandler.setContext(this);
		eventHandlers.add(eventhandler);
	}

	/**
	 * Specifies an EventEffect to be executed upon each entering of the specified
	 * State.
	 *
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateEnteredHandler(final RealtimeBoolean state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateEntered(state, effect, this));
	}

	/**
	 * Specifies an EventEffect to be executed upon the first entering of the
	 * specified State only.
	 *
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateFirstEnteredHandler(final RealtimeBoolean state, final EventEffect effect)
			throws RoboticsException {
		addEventHandler(EventHandler.OnStateFirstEntered(state, effect, this));
	}

	/**
	 * Specifies an EventEffect to be executed upon the each leaving of the
	 * specified State.
	 *
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateLeftHandler(final RealtimeBoolean state, final EventEffect effect) throws RoboticsException {
		addEventHandler(EventHandler.OnStateLeft(state, effect, this));
	}

	/**
	 * Specifies an EventEffect to be executed upon the first leaving of the
	 * specified State only.
	 *
	 * @param state  the State to react to
	 * @param effect the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public void addStateFirstLeftHandler(final RealtimeBoolean state, final EventEffect effect)
			throws RoboticsException {
		addEventHandler(EventHandler.OnStateFirstLeft(state, effect, this));
	}

	/**
	 * Specifies an EventEffect to be executed upon each occurrence of the specified
	 * error.
	 *
	 * @param <T>
	 *
	 * @param exceptionType the type of exception to react to
	 * @param effect        the effect to execute
	 * @param handled       if the handler handles the exception completely;
	 *                      otherwise it will be propagated
	 * @throws RoboticsException if Command is already sealed
	 */
	public <T extends CommandRealtimeException> void addExceptionHandler(final Class<T> exceptionType,
			final EventEffect effect, boolean handled) throws RoboticsException {

		addStateEnteredHandler(getExceptionState(exceptionType), effect);
		if (handled) {
			ignoreException(exceptionType);
		}
	}

	public RealtimeBoolean getExceptionState(Class<? extends CommandRealtimeException> exceptionType) {
		List<CommandRealtimeException> exceptions = getExceptions(exceptionType);
		if (exceptions.size() == 1) {
			return getExceptionState(exceptions.get(0));
		}
		RealtimeBoolean ret = RealtimeBoolean.FALSE;
		for (CommandRealtimeException e : exceptions) {
			ret = ret.or(getExceptionState(e));
		}
		return ret;
	}

	public RealtimeBoolean getExceptionState(CommandRealtimeException exception) {
		return RealtimeBoolean.createFromException(exception);
	}

	/**
	 * Specifies an EventEffect to be executed upon each occurrence of the specified
	 * error. The error is not treated as handled (i.e. will be propagated).
	 *
	 * @param <T>
	 *
	 * @param exceptionType the type of exception to react to
	 * @param effect        the effect to execute
	 * @throws RoboticsException if Command is already sealed
	 */
	public <T extends CommandRealtimeException> void addExceptionHandler(final Class<T> exceptionType,
			final EventEffect effect) throws RoboticsException {

		addExceptionHandler(exceptionType, effect, false);
	}

	/**
	 * Retrieves the runtime of the command
	 *
	 * @return the robotics runtimes
	 */
	public RoboticsRuntime getRuntime() {
		return runtime;
	}

	/**
	 * Start execution of the command.
	 *
	 * @return An RPI RCC net for the command
	 * @throws RoboticsException when an error occurs
	 */
	public CommandHandle start() throws RoboticsException {
		CommandHandle ret = load();
		ret.start();
		return ret;
	}

	/**
	 * Schedule this Command for execution right after a currently running Command.
	 *
	 * The CommandHandle of the currently running Command has to be specified.
	 *
	 * @param other CommandHandle of the Command that this Command should be
	 *              scheduled after
	 * @return the CommandHandle for this Command
	 * @throws RoboticsException if Command scheduling failed
	 */
	public CommandHandle scheduleAfter(CommandResult other) throws RoboticsException {
		CommandHandle ret = load();
		ret.scheduleAfter(other);
		return ret;
	}

	/**
	 * Prepares this Command for execution.
	 *
	 * This involves creating default EventHandlers for unhandled errors and
	 * creating EventHandlers for command completion.
	 *
	 * @param errorStack
	 *
	 * @throws RoboticsException if sealing failed
	 */
	public void seal(StackTraceElement[] errorStack) throws RoboticsException {
		if (sealed) {
			return;
		}

		errorStackTrace = errorStack;
		for (CommandHook hook : getRuntime().getCommandHooks()) {
			hook.commandSealHook(this);
		}

		createErrorResults();

		sealed = true;
	}

	/**
	 * Checks if this Command is sealed (see seal()).
	 *
	 * @return true, if Command is sealed
	 */
	public boolean isSealed() {
		return sealed;
	}

	/**
	 * Loads this Command to its RoboticsRuntime.
	 *
	 * @return the CommandHandle for this Command
	 * @throws RoboticsException if loading failed
	 */
	public CommandHandle load() throws RoboticsException {
		// return handle if already loaded
		if (loadCount == -1)
			throw new IllegalStateException("The command has already been unloaded.");

		loadCount++;
		if (getCommandHandle() != null) {
			return getCommandHandle();
		}

		List<CommandHook> commandHooks = getRuntime().getCommandHooks();
		for (CommandHook hook : commandHooks) {
			hook.commandLoadHook(this);
		}

		seal(new Exception().getStackTrace());

		CommandHandle handle = createHandle();

		for (CommandHook hook : commandHooks) {
			hook.commandHandleHook(handle);
		}

		return handle;
	}

	private StackTraceElement[] errorStackTrace = null;

	protected abstract CommandHandle createHandle() throws RoboticsException;

	/**
	 * Creates EventHandlers for unhandled errors inside this Command (i.e. result
	 * of getUnhandledInnerErrors()).
	 *
	 * @throws RoboticsException if creating error handlers failed
	 */
	protected void createErrorResults() throws RoboticsException {
		if (getExceptions().isEmpty()) {
			return;
		}

		final UnhandledErrorsException ex = new UnhandledErrorsException();
		ex.setStackTrace(errorStackTrace);
		RealtimeBoolean cond = RealtimeBoolean.FALSE;
		for (final CommandRealtimeException error : new ArrayList<CommandRealtimeException>(getExceptions())) {
			error.setStackTrace(errorStackTrace);
			error.setCommand(this);
			addObserver(getExceptionState(error), new RealtimeValueListener<Boolean>() {
				@Override
				public void onValueChanged(Boolean newValue) {
					if (newValue) {
						ex.addInnerException(error);
					}

				}
			});
			cond = cond.or(getExceptionState(error));
		}
		commandResults.put(cond, new CommandResult(ex.getClass().getName(), this, ex, false, true));
	}

	/**
	 * Start execution of the command and wait for completion
	 *
	 * @throws RoboticsException when an error occurs
	 */
	public void execute() throws RoboticsException {
		start().waitComplete();
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 *
	 * @param <T>      Generic type of the Observer.
	 * @param sensor   The sensor value to observe.
	 * @param listener The listener observing the sensor value.
	 * @throws RoboticsException
	 */
	public <T> void addObserver(RealtimeValue<T> sensor, RealtimeValueListener<T> listener) throws RoboticsException {
		addObserver(sensor.createObserver(listener, null, false));
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 *
	 * @param <T>       Generic type of the Observer.
	 * @param sensor    The sensor value to observe.
	 * @param listener  The listener observing the sensor value.
	 * @param condition the condition when to observe the value
	 * @throws RoboticsException
	 */
	public <T> void addObserver(RealtimeValue<T> sensor, RealtimeValueListener<T> listener, RealtimeBoolean condition)
			throws RoboticsException {
		addObserver(sensor.createObserver(listener, condition, false));
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 *
	 * @param <T>      Generic type of the Observer.
	 * @param sensor   The sensor value to observe.
	 * @param listener The listener observing the sensor value.
	 * @param async    Notify the listener asynchronously
	 * @throws RoboticsException
	 *
	 */
	public <T> void addObserver(RealtimeValue<T> sensor, RealtimeValueListener<T> listener, boolean async)
			throws RoboticsException {
		addObserver(sensor.createObserver(listener, null, async));
	}

	/**
	 * Registers a SensorListener that observes the given Sensor while this Command
	 * is running.
	 *
	 * @param <T>       Generic type of the Observer.
	 * @param sensor    The sensor value to observe.
	 * @param listener  The listener observing the sensor value.
	 * @param condition The condition when to observe the value
	 * @param async     Notify the listener asynchronously
	 * @throws RoboticsException
	 *
	 */
	public <T> void addObserver(RealtimeValue<T> sensor, RealtimeValueListener<T> listener, RealtimeBoolean condition,
			boolean async) throws RoboticsException {
		addObserver(sensor.createObserver(listener, condition, async));
	}

	/**
	 * Adds an Observer to this Command explicitly.
	 *
	 * @param observer The Observer to add.
	 * @throws RoboticsException
	 */
	protected <T> void addObserver(Observer<T> observer) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		if (!observer.getSensor().isAvailable()) {
			throw new RoboticsException("The given sensor is not available.");
		}
		observer.setCommand(this);
		observers.add(observer);
	}

	/**
	 * Retrieves the command handle of the (running) command
	 *
	 * @return command handle
	 */
	public CommandHandle getCommandHandle() {
		return commandHandle;
	}

	/**
	 * Sets the command handle of the running command
	 *
	 * @param handle command handle of this command
	 */
	protected void setCommandHandle(final CommandHandle handle) {
		commandHandle = handle;
	}

	/**
	 * Gets the ExceptionHandler used for handling CommandExceptions during
	 * execution of this Command.
	 *
	 * @return the ExceptionHandler
	 */
	public UnhandledExceptionHandler getUnhandledExceptionHandler() {
		return exceptionHandler;
	}

	/**
	 * Sets ExceptionHandler for this Command.
	 *
	 * @param handler the new ExceptionHandler
	 */
	public void setUnhandledExceptionHandler(UnhandledExceptionHandler handler) {
		this.exceptionHandler = handler;
	}

	/**
	 * Gets the exception aggregator used for this command
	 */
	public ExceptionAggegator getExceptionAggregator() {
		return exceptionAggregator;
	}

	/**
	 * Sets ExceptionAggregator for this Command.
	 *
	 * @param exceptionAggregator the new ExceptionAggregator
	 */
	public void setExceptionAggregator(ExceptionAggegator exceptionAggregator) {
		this.exceptionAggregator = exceptionAggregator;
	}

	/**
	 * Retrieves the Observers of this Command.
	 *
	 * @return list of Observers
	 */
	public List<Observer<?>> getObservers() {
		return observers;
	}

	/**
	 * Gets whether this command needs a stable connection to the Robotics API
	 * during execution
	 *
	 * @return if keep alive mechanism is necessary
	 */
	public boolean needsWatchdog() {
		return watchdogTimeout > 0;
	}

	/**
	 * Gets the timeout (in s) after which the connection to the Robotics API is
	 * assumed to have failed during execution of this Action.
	 *
	 * @return the watchdog timeout
	 */
	public double getWatchdogTimeout() {
		return watchdogTimeout;
	}

	/**
	 * Sets the timeout (in s) after which the connection to the Robotics API is
	 * assumed to have failed during execution of this Action. A value of 0 (zero)
	 * has the meaning of an infinite timeout (i.e., no check).
	 *
	 * @param watchdogTimeout the timeout for the watchdog in s
	 * @throws RoboticsException
	 */
	public void setWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		if (watchdogTimeout < 0) {
			throw new IllegalArgumentException("watchdogTimeout");
		}

		this.watchdogTimeout = watchdogTimeout;
	}

	/**
	 * Sets the watchdog timeout of this Command to the specified value.
	 *
	 * @param watchdogTimeout the watchdog timeout value
	 * @throws RoboticsException if Command is already sealed
	 */
	public void overrideWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		setWatchdogTimeout(watchdogTimeout);

		overrideWatchdogTimeoutInternal(watchdogTimeout);
	}

	/**
	 * Sets the watchdog timeout of this Command to the specified value, if this
	 * already Command uses a watchdog and the current timeout is shorter than the
	 * specified value.
	 *
	 * @param watchdogTimeout the watchdog timeout
	 * @throws RoboticsException the robotics exception
	 */
	public void relaxWatchdogTimeout(double watchdogTimeout) throws RoboticsException {
		if (this.watchdogTimeout != 0 && this.watchdogTimeout < watchdogTimeout) {
			setWatchdogTimeout(watchdogTimeout);

			relaxWatchdogTimeoutInternal(watchdogTimeout);
		}
	}

	/**
	 * Sets the watchdog timeout of this Command implementation to the specified
	 * value.
	 *
	 * @param watchdogTimeout the watchdog timeout value
	 * @throws RoboticsException if Command is already sealed
	 */
	protected abstract void overrideWatchdogTimeoutInternal(double watchdogTimeout) throws RoboticsException;

	/**
	 * Sets the watchdog timeout of this Command implementation to the specified
	 * value, if this already Command uses a watchdog and the current timeout is
	 * shorter than the specified value.
	 *
	 * @param watchdogTimeout the watchdog timeout
	 * @throws RoboticsException the robotics exception
	 */
	protected abstract void relaxWatchdogTimeoutInternal(double watchdogTimeout) throws RoboticsException;

	/**
	 * Gets all errors that can occur inside this Command during its execution and
	 * for which no EventHandler has been specified.
	 *
	 * @return List of States that represent unhandled errors
	 */
	public List<CommandRealtimeException> getExceptions() {
		List<CommandRealtimeException> unhandled = new ArrayList<CommandRealtimeException>(getInnerExceptions());
		unhandled.removeAll(handledExceptions);
		return unhandled;
	}

	protected Map<RealtimeBoolean, CommandResult> commandResults = new HashMap<RealtimeBoolean, CommandResult>();
	protected List<RealtimeBoolean> cancelConditions = new ArrayList<RealtimeBoolean>();

	public void addCancelCondition(RealtimeBoolean condition) {
		cancelConditions.add(condition);
	}

	public List<RealtimeBoolean> getCancelConditions() {
		return Collections.unmodifiableList(cancelConditions);
	}

	public List<CommandResult> getCommandResults() {
		return new ArrayList<CommandResult>(commandResults.values());
	}

	public List<RealtimeBoolean> getResultConditions(CommandResult result) {
		List<RealtimeBoolean> ret = new ArrayList<RealtimeBoolean>();
		for (Entry<RealtimeBoolean, CommandResult> cr : commandResults.entrySet()) {
			if (cr.getValue() == result) {
				ret.add(cr.getKey());
			}
		}
		return ret;
	}

	public List<CommandResult> getTakeoverResults() {
		List<CommandResult> ret = new ArrayList<CommandResult>();
		for (CommandResult result : commandResults.values()) {
			if (!result.isCompleted()) {
				ret.add(result);
			}
		}
		return ret;
	}

	public List<CommandResult> getExceptionResults() {
		List<CommandResult> ret = new ArrayList<CommandResult>();
		for (CommandResult result : commandResults.values()) {
			if (result.getException() != null) {
				ret.add(result);
			}
		}
		return ret;
	}

	public RealtimeBoolean getExceptionCondition(CommandRealtimeException exception) {
		return exceptionConditions.get(exception);
	}

	public List<CommandResult> getCompletionResults() {
		List<CommandResult> ret = new ArrayList<CommandResult>();
		for (CommandResult result : commandResults.values()) {
			if (result.isCompleted() && result.getException() == null) {
				ret.add(result);
			}
		}
		return ret;
	}

	/**
	 * Specifies an additional condition that leads to this Command's completion.
	 *
	 * The returned CommandResult is reached when the state occurs.
	 *
	 * @param name      name of the command result
	 * @param condition the condition for the occurrence of this Command's
	 *                  CommandResult
	 * @param cancelled true if this result can only be reached after cancelling
	 * @return the created command result
	 * @throws RoboticsException if Command already sealed
	 */
	public CommandResult addCompletionResult(String name, RealtimeBoolean condition, boolean cancelled)
			throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		CommandResult result = new CommandResult(name, this, null, cancelled, true);
		commandResults.put(condition, result);
		return result;
	}

	/**
	 * Specifies a State that indicates that this Command allows to be taken over.
	 *
	 * The command result is active when the given state occurs, and can be used to
	 * takeover the command in exactly this state.
	 *
	 * @param name      name of the result
	 * @param condition the state indicating takeover allowed
	 * @param cancelled true if this result can only be reached after cancelling
	 * @return the created command result
	 * @throws RoboticsException if Command already sealed
	 */
	public CommandResult addTakeoverResult(String name, RealtimeBoolean condition, boolean cancelled)
			throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}

		CommandResult result = new CommandResult(name, this, null, cancelled, false);
		commandResults.put(condition, result);
		return result;
	}

	public List<CommandResult> addErrorResults(Class<? extends CommandRealtimeException> exception)
			throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		List<CommandResult> ret = new ArrayList<CommandResult>();
		for (CommandRealtimeException e : getExceptions(exception)) {
			CommandResult result = new CommandResult(e.getClass().getName(), this, e, false, true);
			commandResults.put(getExceptionState(e), result);
			ret.add(result);
			handledExceptions.add(e);
		}
		return ret;
	}

	public <T> void assign(RealtimeValue<T> source, PersistContext<T> target) {
		assignments.add(new Assignment<T>(source, target));
	}

	public <T> void assign(RealtimeValue<T> source, PersistContext<T> target, RealtimeBoolean condition) {
		assignments.add(new Assignment<T>(source, target, condition));
	}

	public List<Assignment<?>> getAssignments() {
		return assignments;
	}

	public void addExceptionCondition(RealtimeBoolean state, CommandRealtimeException exception)
			throws RoboticsException {
		if (sealed) {
			throw new RoboticsException("Command is already sealed");
		}
		if (exception.getCommand() == null) {
			exception.setCommand(this);
		}
		if (getInnerExceptions().contains(exception)) {
			throw new RoboticsException("This exception already exists in the command.");
		}
		exceptionConditions.put(exception, state);
	}

	public void ignoreException(Class<? extends CommandRealtimeException> exceptionType) {
		for (CommandRealtimeException e : getExceptions(exceptionType)) {
			handledExceptions.add(e);
		}
	}

	public void ignoreException(CommandRealtimeException exception) {
		handledExceptions.add(exception);
	}

	protected void applyFilter(CommandFilter filter) {
		if (filter.filter(this)) {
			filter.process(this);
		}
	}

	boolean validateRealtimeValue(RealtimeValue<?> value) {
		if (value == null) {
			return false;
		}
		if (value.getRuntime() != null && value.getRuntime() != getRuntime()) {
			return false;
		}
		if (value.getScope() != null && value.getScope() != this) {
			return false;
		}
		return true;
	}

	public CommandOperation getStartOperation() {
		return new CommandOperation(this) {
			@Override
			public CommandHandleOperation getHandleOperation() {
				return getCommandHandle().getStartOperation();
			}
		};
	}

	public CommandOperation getCancelOperation() {
		return new CommandOperation(this) {
			@Override
			public CommandHandleOperation getHandleOperation() {
				return getCommandHandle().getCancelOperation();
			}
		};
	}

	public CommandOperation getAbortOperation() {
		return new CommandOperation(this) {
			@Override
			public CommandHandleOperation getHandleOperation() {
				return getCommandHandle().getAbortOperation();
			}
		};
	}

	public RealtimeDouble getCommandExecutionTime() {
		return commandExecutionTime;
	}

	public void unload() throws CommandException {
		if (loadCount > 0) {
			loadCount--;
			if (loadCount == 0) {
				commandHandle.unload();
				loadCount = -1;
			}
		}
	}

}
